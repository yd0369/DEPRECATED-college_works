#!/bin/bash
function welcome_function() {
    clear
    printf "Yash Desai - Microproject of Operating System\n\n"
}

function shell_variables() {
    printf "[[ Shell Variables ]]\n\n"
    printf "1. Bourne Shell Variables"
    printf " (Variables which Bash uses in the same way as the Bourne Shell.)\n"
    printf "2. Bash Variables"
    printf "         (List of variables that exist in Bash.)\n"
    printf "\nWhich one you want to explore : "
    read shell_variables_user_selection
    if [ $shell_variables_user_selection == "1" ] 
        then Bourne_Shell_Variables
    else 
        if [ $shell_variables_user_selection == "2" ] 
            then BASH_Variables
            else shell_variables_incorrect_option
        fi
    fi
}

function Bourne_Shell_Variables() {
    clear
    printf "\t\t\t<<<   Bourne Shell Variables   >>>\n\n"
    printf "Bash uses certain shell variables in the"
    printf " same way as the Bourne shell.\n"
    printf "In some cases, Bash assigns a "
    printf "default value to the variable."
    printf "\n"
    printf "\n\t [  1 ]      CDPATH"
    printf "\n\t [  2 ]      HOME"
    printf "\n\t [  3 ]      IFS"
    printf "\n\t [  4 ]      MAIL"
    printf "\n\t [  5 ]      MAILPATH"
    printf "\n\t [  6 ]      OPTARG"
    printf "\n\t [  7 ]      OPTIND"
    printf "\n\t [  8 ]      PATH"
    printf "\n\t [  9 ]      PS1"
    printf "\n\t [ 10 ]      PS2"
    printf "\nSelect the variable via assigned number : "
    read Bourne_Shell_Variables_user_selection
    case "$Bourne_Shell_Variables_user_selection" in
        1)  Bourne_Shell_Variable_HELPER 1 
            ;;
        2)  Bourne_Shell_Variable_HELPER 2
            ;;
        3)  Bourne_Shell_Variable_HELPER 3
            ;;
        4)  Bourne_Shell_Variable_HELPER 4
            ;;
        5)  Bourne_Shell_Variable_HELPER 5
            ;;
        6)  Bourne_Shell_Variable_HELPER 6
            ;;
        7)  Bourne_Shell_Variable_HELPER 7
            ;;
        8)  Bourne_Shell_Variable_HELPER 8
            ;;
        9)  Bourne_Shell_Variable_HELPER 9
            ;;
        10) Bourne_Shell_Variable_HELPER 10
            ;;
        *)  Bourne_Shell_Variables_incorrect_option
            ;;
    esac    
}

function BASH_Variables() {
    clear
    printf "\t\t\t<<<   BASH Variables   >>>\n\n"
    printf "These variables are set or used by Bash, "
    printf "but other shells do not normally treat "
    printf "them specially.\n"
    printf "A few variables used by Bash are described "
    printf "in different chapters: \n"
    printf "variables for controlling the job "
    printf "control facilities."
    printf "\n"
    printf "\n\t [   1 ]      BASH"
    printf "\n\t [   2 ]      BASHOPTS"
    printf "\n\t [   3 ]      BASHPID"
    printf "\n\t [   4 ]      BASH_ALIASES"
    printf "\n\t [   5 ]      BASH_ARGC"
    printf "\n\t [   6 ]      BASH_ARGV"
    printf "\n\t [   7 ]      BASH_ARGV0"
    printf "\n\t [   8 ]      BASH_CMDS"
    printf "\n\t [   9 ]      BASH_COMMAND"
    printf "\n\t [  10 ]      BASH_COMPAT"
    printf "\n\t [  11 ]      BASH_ENV"
    printf "\n\t [  12 ]      BASH_EXECUTION_STRING"
    printf "\n\t [  13 ]      BASH_LINENO"
    printf "\n\t [  14 ]      BASH_LOADABLES_PATH"
    printf "\n\t [  15 ]      BASH_REMATCH"
    printf "\n\t [  16 ]      BASH_SOURCE"
    printf "\n\t [  17 ]      BASH_SUBSHELL"
    printf "\n\t [  18 ]      BASH_VERSINFO"
    printf "\n\t [  19 ]      BASH_VERSINFO[0]"
    printf "\n\t [  20 ]      BASH_VERSINFO[1]"
    printf "\n\t [  21 ]      BASH_VERSINFO[2]"
    printf "\n\t [  22 ]      BASH_VERSINFO[3]"
    printf "\n\t [  23 ]      BASH_VERSINFO[4]"
    printf "\n\t [  24 ]      BASH_VERSINFO[5]"
    printf "\n\t [  25 ]      BASH_VERSION"
    printf "\n\t [  26 ]      BASH_XTRACEFD"
    printf "\n\t [  27 ]      CHILD_MAX"
    printf "\n\t [  28 ]      COLUMNS"
    printf "\n\t [  29 ]      COMP_CWORD"
    printf "\n\t [  30 ]      COMP_LINE"
    printf "\n\t [  31 ]      COMP_POINT"
    printf "\n\t [  32 ]      COMP_TYPE"
    printf "\n\t [  33 ]      COMP_KEY"
    printf "\n\t [  34 ]      COMP_WORDBREAKS"
    printf "\n\t [  35 ]      COMP_WORDS"
    printf "\n\t [  36 ]      COMPREPLY"
    printf "\n\t [  37 ]      COPROC"
    printf "\n\t [  38 ]      DIRSTACK"
    printf "\n\t [  39 ]      EMACS"
    printf "\n\t [  40 ]      ENV"
    printf "\n\t [  41 ]      EPOCHREALTIME"
    printf "\n\t [  42 ]      EPOCHSECONDS"
    printf "\n\t [  43 ]      EUID"
    printf "\n\t [  44 ]      EXECIGNORE"
    printf "\n\t [  45 ]      FCEDIT"
    printf "\n\t [  46 ]      FIGNORE"
    printf "\n\t [  47 ]      FUNCNAME"
    printf "\n\t [  48 ]      FUNCNEST"
    printf "\n\t [  49 ]      GLOBIGNORE"
    printf "\n\t [  50 ]      GROUPS"
    printf "\n\t [  51 ]      histchars"
    printf "\n\t [  52 ]      HISTCMD"
    printf "\n\t [  53 ]      HISTCONTROL"
    printf "\n\t [  54 ]      HISTFILE"
    printf "\n\t [  55 ]      HISTFILESIZE"
    printf "\n\t [  56 ]      HISTIGNORE"
    printf "\n\t [  57 ]      HISTSIZE"
    printf "\n\t [  58 ]      HISTTIMEFORMAT"
    printf "\n\t [  59 ]      HOSTFILE"
    printf "\n\t [  60 ]      HOSTNAME"
    printf "\n\t [  61 ]      HOSTTYPE"
    printf "\n\t [  62 ]      IGNOREEOF"
    printf "\n\t [  63 ]      INPUTRC"
    printf "\n\t [  64 ]      INSIDE_EMACS"
    printf "\n\t [  65 ]      LANG"
    printf "\n\t [  66 ]      LC_ALL"
    printf "\n\t [  67 ]      LC_COLLATE"
    printf "\n\t [  68 ]      LC_CTYPE"
    printf "\n\t [  69 ]      LC_MESSAGES"
    printf "\n\t [  70 ]      LC_NUMERIC"
    printf "\n\t [  71 ]      LC_TIME"
    printf "\n\t [  72 ]      LINENO"
    printf "\n\t [  73 ]      LINES"
    printf "\n\t [  74 ]      MACHTYPE"
    printf "\n\t [  75 ]      MAILCHECK"
    printf "\n\t [  76 ]      MAPFILE"
    printf "\n\t [  77 ]      OLDPWD"
    printf "\n\t [  78 ]      OPTERR"
    printf "\n\t [  79 ]      OSTYPE"
    printf "\n\t [  80 ]      PIPESTATUS"
    printf "\n\t [  81 ]      POSIXLY_CORRECT"
    printf "\n\t [  82 ]      PPID"
    printf "\n\t [  83 ]      PROMPT_COMMAND"
    printf "\n\t [  84 ]      PROMPT_DIRTRIM"
    printf "\n\t [  85 ]      PS0"
    printf "\n\t [  86 ]      PS3"
    printf "\n\t [  87 ]      PS4"
    printf "\n\t [  88 ]      PWD"
    printf "\n\t [  89 ]      RANDOM"
    printf "\n\t [  90 ]      READLINE_LINE"
    printf "\n\t [  91 ]      READLINE_POINT"
    printf "\n\t [  92 ]      REPLY"
    printf "\n\t [  93 ]      SECONDS"
    printf "\n\t [  94 ]      SHELL"
    printf "\n\t [  95 ]      SHELLOPTS"
    printf "\n\t [  96 ]      SHLVL"
    printf "\n\t [  97 ]      TIMEFORMAT"
    printf "\n\t [  98 ]      TMOUT"
    printf "\n\t [  99 ]      TMPDIR"
    printf "\n\t [ 100 ]      UID"
    printf "\nSelect the variable via assigned number : "
    read Bash_Variables_user_selection
    if ((1 <= Bash_Variables_user_selection <= 100))
      then BASH_Variable_HELPER $Bash_Variables_user_selection
      else BASH_Variables_incorrect_option
    fi
}

function Bourne_Shell_Variable_HELPER() {
    clear
    printf "Bourne Shell Variable   -  "
    case "$1" in
        1)  printf "CDPATH\n\n"
            printf "\tA colon-separated list of directories.\n"
            printf "\tIt is used as a search path for the "
            printf "cd builtin command."
            printf "\n\n\n\n"
            printf "Current State Value of CDPATH : $CDPATH"
            ;;
        2)  printf "HOME\n\n"
            printf "\tThe current user’s home directory.\n"
            printf "\tThe default for the cd builtin command.\n"
            printf "\tThe value of this variable is also used by "
            printf "tilde expansion"
            printf "\n\n\n\n"
            printf "Current State Value of HOME : $HOME"
            ;;
        3)  printf "IFS\n\n"
            printf "\tA list of characters that separate fields.\n"
            printf "\tIt is used when the shell splits words as "
            printf "part of expansion.\n"
            printf "\n\n\n\n"
            printf "Current State Value of IFS : $IFS"
            ;;
        4)  printf "MAIL\n\n"
            printf "\tIf this parameter is set to a filename"
            printf "or directory name.\n"
            printf "\tThe MAILPATH variable is not set.\n"
            printf "\tBash informs the user of the arrival of mail"
            printf "in the specified file or Maildir-format directory."
            printf "\n\n\n\n"
            printf "Current State Value of MAIL : $MAIL"
            ;;
        5)  printf "MAILPATH\n\n"
            printf "\tA colon-separated list of filenames which "
            printf "the shell periodically checks for new mail.\n"
            printf "\tEach list entry can specify the message that "
            printf "is printed when new mail arrives in the mail "
            printf "file by separating the filename from the "
            printf "message with a ‘?’.\n"
            printf "\tWhen used in the text of the message "
            printf "$ _ expands to the name of the current mail file."
            printf "\n\n\n\n"
            printf "Current State Value of MAILPATH : $MAILPATH"
            ;;
        6)  printf "OPTARG\n\n"
            printf "\tThe value of the last option argument "
            printf "processed by the getopts builtin."
            printf "\n\n\n\n"
            printf "Current State Value of OPTARG : $OPTARG"
            ;;
        7)  printf "OPTIND\n\n"
            printf "\tThe index of the last option argument "
            printf "processed by the getopts builtin."
            printf "\n\n\n\n"
            printf "Current State Value of OPTIND : $OPTIND"
            ;;
        8)  printf "PATH\n\n"
            printf "\tA colon-separated list of directories in which "
            printf "the shell looks for commands.\n"
            printf "\tA zero-length (null) directory name in the "
            printf "value of PATH indicates the current directory.\n"
            printf "\tA null directory name may appear as two "
            printf "adjacent colons, or as an initial or "
            printf "trailing colon.\n"
            printf "\n\n\n\n"
            printf "Current State Value of PATH : $PATH"
            ;;
        9)  printf "PS1\n\n"
            printf "\tThe primary prompt string.\n"
            printf "\tThe default value is ‘\s-\v\ $ ’.\n"        
            printf "\n\n\n\n"
            printf "Current State Value of PS1 : $PS1"
            ;;
        10) printf "PS2\n\n"
            printf "\tThe secondary prompt string.\n"
            printf "\tThe default value is ‘> ’.\n"
            printf "\tPS2 is expanded in the same way "
            printf "as PS1 before being displayed."
            printf "\n\n\n\n"
            printf "Current State Value of PS2 : $PS2"
            ;;
    esac
    EXIT    
}

function BASH_Variable_HELPER() {
    clear
    printf "BASH Variable   -  "
    case "$1" in
        1)  printf "BASH\n\n"
            printf "\tThe full pathname used to execute the "
            printf "current instance of Bash."
            printf "\n\n\n\n"
            printf "Current State Value of BASH : $BASH"
            ;;
        2)  printf "BASHOPTS\n\n"
            printf "\tA colon-separated list of enabled shell options.\n"
            printf "\tEach word in the list is a valid argument for the "
            printf "- s option to the shopt builtin command. \n"
            printf "\tThe options appearing in BASHOPTS are those "
            printf "reported as ‘on’ by ‘shopt’. \n"
            printf "\tIf this variable is in the environment when Bash "
            printf "starts up, each shell option in the list will be "
            printf "enabled before reading any startup files. \n"
            printf "\tThis variable is readonly."
            printf "\n\n\n\n"
            printf "Current State Value of BASHOPTS : $BASHOPTS"
            ;;
        3)  printf "BASHPID\n\n"
            printf "\tExpands to the process ID of the current Bash process.\n"
            printf "\tThis differs from $ $ under certain circumstances, "
            printf "such as subshells that do not require Bash to be "
            printf "re-initialized. \n "
            printf "\tAssignments to BASHPID have no effect. \n"
            printf "\tIf BASHPID is unset, it loses its special "
            printf "properties, even if it is subsequently reset.\n"
            printf "\n\n\n\n"
            printf "Current State Value of BASHPID : $BASHPID"
            ;;
        4)  printf "BASH_ALIASES\n\n"
            printf "\nAn associative array variable whose members "
            printf "correspond to the internal list of aliases "
            printf "as maintained by the alias builtin. \n"        
            printf "Elements added to this array appear in the alias list\n"
            printf "However, unsetting array elements currently does not "
            printf "cause aliases to be removed from the alias list.\n"
            printf "If BASH_ALIASES is unset, it loses its special "
            printf "properties, even if it is subsequently reset.\n"
            printf "\n\n\n\n"
            printf "Current State Value of BASH_ALIASES : $BASH_ALIASES"
            ;;
        5)  printf "BASH_ARGC\n\n"
            printf "An array variable whose values are the number of "
            printf "parameters in each frame of the current bash "
            printf "execution call stack.\n"
            printf "The number of parameters to the current subroutine "
            printf "(shell function or script executed with . or source) " 
            printf "is at the top of the stack. \n"
            printf "When a subroutine is executed, the number of "
            printf "parameters passed is pushed onto BASH_ARGC. \n"
            printf "The shell sets BASH_ARGC only when in extended " 
            printf "debugging mode. \n"
            printf "Setting extdebug after the shell has started to "
            printf "execute a script, or referencing this variable "
            printf "when extdebug is not set, may result in "
            printf "inconsistent values. \n"
            printf "\n\n\n\n"
            printf "Current State Value of BASH_ARGC : $BASH_ARGC"
            ;;
        6)  printf "BASH_ARGV\n\n"
            printf "An array variable containing all of the parameters "
            printf "in the current bash execution call stack. \n\n"
            printf "The final parameter of the last subroutine call " 
            printf "is at the top of the stack; the first parameter "
            printf "of the initial call is at the bottom. \n\n"
            printf "When a subroutine is executed, the parameters " 
            printf "supplied are pushed onto BASH_ARGV. \n\n"
            printf "The shell sets BASH_ARGV only when in extended "
            printf "debugging mode. \n\n"
            printf "Setting extdebug after the shell has started "
            printf "to execute a script, or referencing this  "
            printf "variable when extdebug is not set, may  "
            printf "result in inconsistent values.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of BASH_ARGV : $BASH_ARGV"
            ;;
        7)  printf "BASH_ARGV0\n\n"
            printf "When referenced, this variable expands to the  "
            printf "name of the shell or shell script "
            printf "(identical to $ 0; See Special Parameters, "
            printf "for the description of special parameter 0).\n\n"
            printf "Assignment to BASH_ARGV0 causes the value  "
            printf "assigned to also be assigned to $ 0. \n\n"
            printf "If BASH_ARGV0 is unset, it loses its "
            printf "special properties, even if it is  "
            printf "subsequently reset.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of BASH_ARGV0 : $BASH_ARGV0"
            ;;
        8)  printf "BASH_CMDS\n\n"
            printf "An associative array variable whose members "
            printf "correspond to the internal hash table of "
            printf "commands as maintained by the hash builtin. \n\n"
            printf "Elements added to this array appear in the " 
            printf "hash table; however, unsetting array elements "
            printf "currently does not cause command names to be "
            printf "removed from the hash table. \n\n"
            printf "If BASH_CMDS is unset, it loses its special "
            printf "properties, even if it is subsequently reset.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of BASH_CMDS : $BASH_CMDS"
            ;;
        9)  printf "BASH_COMMAND\n\n"
            printf "The command currently being executed or "
            printf "about to be executed, unless the shell is "
            printf "executing a command as the result of a trap, "
            printf "in which case it is the command executing at "
            printf "the time of the trap.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of BASH_COMMAND : $BASH_COMMAND"
            ;;
        10) printf "BASH_COMPAT\n\n"
            printf "The value is used to set the shell’s "
            printf "compatibility level. \n\n"
            printf "The value may be a decimal number (e.g., 10.2) "
            printf "or an integer (e.g., 42) corresponding to "
            printf "the desired compatibility level. \n\n"
            printf "If BASH_COMPAT is unset or set to the "
            printf "empty string, the compatibility level "
            printf "is set to the default for the current version. \n\n"
            printf "If BASH_COMPAT is set to a value that "
            printf "is not one of the valid compatibility "
            printf "levels, the shell prints an error message "
            printf "and sets the compatibility level to the "
            printf "default for the current version. \n\n"
            printf "The valid compatibility levels correspond "
            printf "to the compatibility options accepted by "
            printf "the shopt builtin described above "
            printf "(for example, compat42 means that "
            printf "4.2 and 42 are valid values). \n\n"
            printf "The current version is also a valid value.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of BASH_COMPAT : $BASH_COMPAT"
            ;;
        11) printf "BASH_ENV\n\n"
            printf "If this variable is set when Bash is invoked "
            printf "to execute a shell script, its value is "
            printf "expanded and used as the name of a startup "
            printf "file to read before executing the script. \n\n"
            printf "See Bash Startup Files.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of BASH_ENV : $BASH_ENV"
            ;;
        12) printf "BASH_EXECUTION_STRING\n\n"
            printf "The command argument to the -c invocation "
            printf "option.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of BASH_EXECUTION_STRING : $BASH_EXECUTION_STRING"
            ;;
        13) printf "BASH_LINENO\n\n"
            printf "An array variable whose members are the "
            printf "line numbers in source files where each "
            printf "corresponding member of FUNCNAME was invoked. \n\n"
            printf "$ { BASH_LINENO [ $ i ] }  is the line number "
            printf "in the source file ($ {BASH_SOURCE[$ i+1]}) "
            printf "where $ {FUNCNAME[$ i]} was called (or "
            printf "$ { BASH_LINENO[$ i-1]} if referenced within "
            printf "another shell function). \n\n"
            printf "Use LINENO to obtain the current line number.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of BASH_LINENO : $BASH_LINENO"
            ;;
        14) printf "BASH_LOADABLES_PATH\n\n"
            printf "A colon-separated list of directories in "
            printf "which the shell looks for dynamically "
            printf "loadable builtins specified by the "
            printf "enable command.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of BASH_LOADABLES_PATH : $BASH_LOADABLES_PATH"
            ;;
        15) printf "BASH_REMATCH\n\n"
            printf "An array variable whose members are "
            printf "assigned by the ‘=~’ binary operator "
            printf "to the [[ conditional command. \n\n"
            printf "The element with index 0 is the portion "
            printf "of the string matching the entire regular "
            printf "expression. \n\n"
            printf "The element with index n is the portion "
            printf "of the string matching the nth "
            printf "parenthesized subexpression. \n\n"
            printf "This variable is read-only.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of BASH_REMATCH : $BASH_REMATCH"
            ;;
        16) printf "BASH_SOURCE\n\n"
            printf "An array variable whose members are the "
            printf "source filenames where the corresponding "
            printf "shell function names in the FUNCNAME "
            printf "array variable are defined. \n\n"
            printf "The shell function $ {FUNCNAME[$ i]} is "
            printf "defined in the file $ {BASH_SOURCE[$ i]} "
            printf "and called from $ {BASH_SOURCE[$ i+1]}\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of BASH_SOURCE : $BASH_SOURCE"
            ;;
        17) printf "BASH_SUBSHELL\n\n"
            printf "Incremented by one within each subshell "
            printf "or subshell environment when the "
            printf "shell begins executing in that "
            printf "environment. \n\n"
            printf "The initial value is 0.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of BASH_SUBSHELL : $BASH_SUBSHELL"
            ;;
        18) printf "BASH_VERSINFO\n\n"
            printf "A readonly array variable "
            printf "whose members hold version information "
            printf "for this instance of Bash. \n\n"
            printf "The values assigned to the array members are as follows:\n\n"
            printf "BASH_VERSINFO[0] - The major version number (the release).\n"
            printf "BASH_VERSINFO[1] - The minor version number (the version).\n"
            printf "BASH_VERSINFO[2] - The patch level.\n"
            printf "BASH_VERSINFO[3] - The build version.\n"
            printf "BASH_VERSINFO[4] - The release status (e.g., beta1).\n"
            printf "BASH_VERSINFO[5] - The value of MACHTYPE. \n"
            printf "\n\n\n\n"
            printf "Current State Value of BASH_VERSINFO : $BASH_VERSINFO"
            ;;
        19) printf "BASH_VERSINFO[0]\n\n"
            printf "A readonly array variable "
            printf "whose members hold version information "
            printf "for this instance of Bash. \n\n"
            printf "The values assigned to the array members are as follows:\n\n"
            printf "BASH_VERSINFO[0] - The major version number (the release).\n"
            printf "BASH_VERSINFO[1] - The minor version number (the version).\n"
            printf "BASH_VERSINFO[2] - The patch level.\n"
            printf "BASH_VERSINFO[3] - The build version.\n"
            printf "BASH_VERSINFO[4] - The release status (e.g., beta1).\n"
            printf "BASH_VERSINFO[5] - The value of MACHTYPE. \n"
            printf "\n\n\n\n"
            printf "Current State Value of BASH_VERSINFO[0] : $BASH_VERSINFO[0]"
            ;;
        20) printf "BASH_VERSINFO[1]\n\n"
            printf "A readonly array variable "
            printf "whose members hold version information "
            printf "for this instance of Bash. \n\n"
            printf "The values assigned to the array members are as follows:\n\n"
            printf "BASH_VERSINFO[0] - The major version number (the release).\n"
            printf "BASH_VERSINFO[1] - The minor version number (the version).\n"
            printf "BASH_VERSINFO[2] - The patch level.\n"
            printf "BASH_VERSINFO[3] - The build version.\n"
            printf "BASH_VERSINFO[4] - The release status (e.g., beta1).\n"
            printf "BASH_VERSINFO[5] - The value of MACHTYPE. \n"
            printf "\n\n\n\n"
            printf "Current State Value of BASH_VERSINFO[1] : $BASH_VERSINFO[1]"
            ;;
        21) printf "BASH_VERSINFO[2]\n\n"
            printf "A readonly array variable "
            printf "whose members hold version information "
            printf "for this instance of Bash. \n\n"
            printf "The values assigned to the array members are as follows:\n\n"
            printf "BASH_VERSINFO[0] - The major version number (the release).\n"
            printf "BASH_VERSINFO[1] - The minor version number (the version).\n"
            printf "BASH_VERSINFO[2] - The patch level.\n"
            printf "BASH_VERSINFO[3] - The build version.\n"
            printf "BASH_VERSINFO[4] - The release status (e.g., beta1).\n"
            printf "BASH_VERSINFO[5] - The value of MACHTYPE. \n"
            printf "\n\n\n\n"
            printf "Current State Value of BASH_VERSINFO[2] : $BASH_VERSINFO[2]"
            ;;
        22) printf "BASH_VERSINFO[3]\n\n"
            printf "A readonly array variable "
            printf "whose members hold version information "
            printf "for this instance of Bash. \n\n"
            printf "The values assigned to the array members are as follows:\n\n"
            printf "BASH_VERSINFO[0] - The major version number (the release).\n"
            printf "BASH_VERSINFO[1] - The minor version number (the version).\n"
            printf "BASH_VERSINFO[2] - The patch level.\n"
            printf "BASH_VERSINFO[3] - The build version.\n"
            printf "BASH_VERSINFO[4] - The release status (e.g., beta1).\n"
            printf "BASH_VERSINFO[5] - The value of MACHTYPE. \n"
            printf "\n\n\n\n"
            printf "Current State Value of BASH_VERSINFO[3] : $BASH_VERSINFO[3]"
            ;;
        23) printf "BASH_VERSINFO[4]\n\n"
            printf "A readonly array variable "
            printf "whose members hold version information "
            printf "for this instance of Bash. \n\n"
            printf "The values assigned to the array members are as follows:\n\n"
            printf "BASH_VERSINFO[0] - The major version number (the release).\n"
            printf "BASH_VERSINFO[1] - The minor version number (the version).\n"
            printf "BASH_VERSINFO[2] - The patch level.\n"
            printf "BASH_VERSINFO[3] - The build version.\n"
            printf "BASH_VERSINFO[4] - The release status (e.g., beta1).\n"
            printf "BASH_VERSINFO[5] - The value of MACHTYPE. \n"
            printf "\n\n\n\n"
            printf "Current State Value of BASH_VERSINFO[4] : $BASH_VERSINFO[4]"
            ;;
        24) printf "BASH_VERSINFO[5]\n\n"
            printf "A readonly array variable "
            printf "whose members hold version information "
            printf "for this instance of Bash. \n\n"
            printf "The values assigned to the array members are as follows:\n\n"
            printf "BASH_VERSINFO[0] - The major version number (the release).\n"
            printf "BASH_VERSINFO[1] - The minor version number (the version).\n"
            printf "BASH_VERSINFO[2] - The patch level.\n"
            printf "BASH_VERSINFO[3] - The build version.\n"
            printf "BASH_VERSINFO[4] - The release status (e.g., beta1).\n"
            printf "BASH_VERSINFO[5] - The value of MACHTYPE. \n"
            printf "\n\n\n\n"
            printf "Current State Value of BASH_VERSINFO[5] : $BASH_VERSINFO[5]"
            ;;
        25) printf "BASH_VERSION\n\n"
            printf "The version number of the current instance of Bash.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of BASH_VERSION : $BASH_VERSION"
            ;;
        26) printf "BASH_XTRACEFD\n\n"
            printf "If set to an integer corresponding to a valid "
            printf "file descriptor, Bash will write the trace "
            printf "output generated when ‘set -x’ is enabled to " 
            printf "that file descriptor. \n\n"
            printf "This allows tracing output to be separated "
            printf "from diagnostic and error messages. \n\n"
            printf "The file descriptor is closed when "
            printf "BASH_XTRACEFD is unset or assigned a new value. \n\n"
            printf "Unsetting BASH_XTRACEFD or assigning it the empty "
            printf "string causes the trace output to be sent to the "
            printf "standard error. \n\n"
            printf "Note that setting BASH_XTRACEFD to 2 "
            printf "(the standard error file descriptor) and then "
            printf "unsetting it will result in the standard error "
            printf "being closed.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of BASH_XTRACEFD : $BASH_XTRACEFD"
            ;;
        27) printf "CHILD_MAX\n\n"
            printf "Set the number of exited child status values "
            printf "for the shell to remember. \n\n"
            printf "Bash will not allow this value to be "
            printf "decreased below a POSIX-mandated minimum, "
            printf "and there is a maximum value "
            printf "(currently 8192) that this may not exceed. \n\n"            
            printf "The minimum value is system-dependent.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of CHILD_MAX : $CHILD_MAX"
            ;;
        28) printf "COLUMNS\n\n"
            printf "Used by the select command to determine the "
            printf "terminal width when printing selection lists. \n\n"
            printf "Automatically set if the checkwinsize option "
            printf "is enabled (see The Shopt Builtin), or in an "
            printf "interactive shell upon receipt of a SIGWINCH.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of COLUMNS : $COLUMNS"
            ;;
        29) printf "COMP_CWORD\n\n"
            printf "An index into $ {COMP_WORDS} of the word containing "
            printf "the current cursor position. \n\n"
            printf "This variable is available only in shell functions "
            printf "invoked by the programmable completion facilities.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of COMP_CWORD : $COMP_CWORD"
            ;;
        30) printf "COMP_LINE\n\n"
            printf "The current command line. \n\n"
            printf "This variable is available only in shell functions "
            printf "and external commands invoked by the programmable "
            printf "completion facilities.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of COMP_LINE : $COMP_LINE"
            ;;
        31) printf "COMP_POINT\n\n"
            printf "The index of the current cursor position "
            printf "relative to the beginning of the current command. \n\n"
            printf "If the current cursor position is at the "
            printf "end of the current command, the value of "
            printf "this variable is equal to $ {# COMP_LINE}.\n\n"
            printf "This variable is available only in shell "
            printf "functions and external commands invoked by " 
            printf "the programmable completion facilities.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of COMP_POINT : $COMP_POINT"
            ;;
        32) printf "COMP_TYPE\n\n"
            printf "Set to an integer value corresponding to "
            printf "the type of completion attempted that caused "
            printf "a completion function to be called: \n\n"
            printf "TAB, for normal completion, \n"
            printf "‘?’, for listing completions after successive tabs, \n"
            printf "‘!’, for listing alternatives on partial word completion, \n"
            printf "‘@’, to list completions if the word is not unmodified, or \n"
            printf "‘%’, for menu completion. \n\n"
            printf "This variable is available only in shell functions " 
            printf "and external commands invoked by the programmable "
            printf "completion facilities.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of COMP_TYPE : $COMP_TYPE"
            ;;
        33) printf "COMP_KEY\n\n"
            printf "The key (or final key of a key sequence) used to "
            printf "invoke the current completion function.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of COMP_KEY : $COMP_KEY"
            ;;
        34) printf "COMP_WORDBREAKS\n\n"
            printf "The set of characters that the Readline library "
            printf "treats as word separators when performing word "
            printf "completion. \n\n"
            printf "If COMP_WORDBREAKS is unset, it loses its "
            printf "special properties, even if it is subsequently reset.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of COMP_WORDBREAKS : $COMP_WORDBREAKS"
            ;;
        35) printf "COMP_WORDS\n\n"
            printf "An array variable consisting of the individual "
            printf "words in the current command line. \n\n"
            printf "The line is split into words as Readline would "
            printf "split it, using COMP_WORDBREAKS as described above. \n\n"
            printf "This variable is available only in shell functions "
            printf "invoked by the programmable completion facilities.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of COMP_WORDS : $COMP_WORDS"
            ;;
        36) printf "COMPREPLY\n\n"
            printf "An array variable from which Bash reads the "
            printf "possible completions generated by a shell "
            printf "function invoked by the programmable "
            printf "completion facility. \n\n"
            printf "Each array element contains one possible "
            printf "completion.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of COMPREPLY : $COMPREPLY"
            ;;
        37) printf "COPROC\n\n"
            printf "An array variable created to hold the file "
            printf "descriptors for output from and input to an "
            printf "unnamed coprocess.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of COPROC : $COPROC"
            ;;
        38) printf "DIRSTACK\n\n"
            printf "An array variable containing the current "
            printf "contents of the directory stack. \n\n"
            printf "Directories appear in the stack in the order "
            printf "they are displayed by the dirs builtin. \n\n"
            printf "Assigning to members of this array variable "
            printf "may be used to modify directories already "
            printf "in the stack, but the pushd and popd builtins "
            printf "must be used to add and remove directories.\n\n" 
            printf "Assignment to this variable will not change "
            printf "the current directory. \n\n"
            printf "If DIRSTACK is unset, it loses its special "
            printf "properties, even if it is subsequently reset.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of DIRSTACK : $DIRSTACK"
            ;;
        39) printf "EMACS\n\n"
            printf "If Bash finds this variable in the environment "
            printf "when the shell starts with value ‘t’, it "
            printf "assumes that the shell is running in an "
            printf "Emacs shell buffer and disables line editing.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of EMACS : $EMACS"
            ;;
        40) printf "ENV\n\n"
            printf "Similar to BASH_ENV.\n\n"
            printf "Used when the shell is invoked in POSIX Mode.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of ENV : $ENV"
            ;;
        41) printf "EPOCHREALTIME\n\n"
            printf "Each time this parameter is referenced, "
            printf "it expands to the number of seconds since "
            printf "the Unix Epoch as a floating point value with "
            printf "micro-second granularity. \n\n"
            printf "Assignments to EPOCHREALTIME are ignored. \n\n"
            printf "If EPOCHREALTIME is unset, it loses its "
            printf "special properties, even if it is subsequently "
            printf "reset.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of EPOCHREALTIME : $EPOCHREALTIME"
            ;;
        42) printf "EPOCHSECONDS\n\n"
            printf "Each time this parameter is referenced, "
            printf "it expands to the number of seconds since "
            printf "the Unix Epoch. \n\n"
            printf "Assignments to EPOCHSECONDS are ignored. \n\n"
            printf "If EPOCHSECONDS is unset, it loses its "
            printf "special properties, even if it is "
            printf "subsequently reset.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of EPOCHSECONDS : $EPOCHSECONDS"
            ;;
        43) printf "EUID\n\n"
            printf "The numeric effective user id of the "
            printf "current user. \n\n"
            printf "This variable is readonly.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of EUID : $EUID"
            ;;
        44) printf "EXECIGNORE\n\n"
            printf "A colon-separated list of shell patterns "
            printf "defining the list of filenames to be "
            printf "ignored by command search using PATH. \n\n"
            printf "Files whose full pathnames match one of "
            printf "these patterns are not considered executable "
            printf "files for the purposes of completion and "
            printf "command execution via PATH lookup. \n\n"
            printf "This does not affect the behavior of the "
            printf "[, test, and [[ commands. \n\n"
            printf "Full pathnames in the command hash table "
            printf "are not subject to EXECIGNORE. \n\n"
            printf "Use this variable to ignore shared library " 
            printf "files that have the executable bit set, "
            printf "but are not executable files. \n\n"
            printf "The pattern matching honors the setting "
            printf "of the extglob shell option.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of EXECIGNORE : $EXECIGNORE"
            ;;
        45) printf "FCEDIT\n\n"
            printf "The editor used as a default by the -e "
            printf "option to the fc builtin command.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of FCEDIT : $FCEDIT"
            ;;
        46) printf "FIGNORE\n\n"
            printf "A colon-separated list of suffixes to "
            printf "ignore when performing filename completion. \n\n"
            printf "A filename whose suffix matches one of the "
            printf "entries in FIGNORE is excluded from the list "
            printf "of matched filenames. \n\n"
            printf "A sample value is ‘.o:~’\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of FIGNORE : $FIGNORE"
            ;;
        47) printf "FUNCNAME\n\n"
            printf "An array variable containing the names of all "
            printf "shell functions currently in the execution call "
            printf "stack. \n\n"
            printf "The element with index 0 is the name of any "
            printf "currently-executing shell function. \n"
            printf "The bottom-most element (the one with the "
            printf "highest index) is main. \n\n"
            printf "This variable exists only when a shell "
            printf "function is executing. \n\n"
            printf "Assignments to FUNCNAME have no effect. \n\n"
            printf "If FUNCNAME is unset, it loses its special "
            printf "properties, even if it is subsequently reset.\n\n"
            printf "This variable can be used with BASH_LINENO and "
            printf "BASH_SOURCE. \n\n"
            printf "Each element of FUNCNAME has corresponding "
            printf "elements in BASH_LINENO and BASH_SOURCE to "
            printf "describe the call stack. \n\n"
            printf "For instance, $ { FUNCNAME[$ i]} was called "
            printf "from the file $ {BASH_SOURCE[$ i+1]} at line "
            printf "number $ {BASH_LINENO[$ i]}. \n\n"
            printf "The caller builtin displays the current call "
            printf "stack using this information. \n\n"
            printf "\n\n\n\n"
            printf "Current State Value of FUNCNAME : $FUNCNAME"
            ;;
        48) printf "FUNCNEST\n\n"
            printf "If set to a numeric value greater than 0, "
            printf "defines a maximum function nesting level. \n\n"
            printf "Function invocations that exceed this "
            printf "nesting level will cause the current "
            printf "command to abort. \n\n"
            printf "\n\n\n\n"
            printf "Current State Value of FUNCNEST : $FUNCNEST"
            ;;
        49) printf "GLOBIGNORE\n\n"
            printf "A colon-separated list of patterns defining "
            printf "the set of file names to be ignored by "
            printf "filename expansion. \n\n"
            printf "If a file name matched by a filename expansion "
            printf "pattern also matches one of the patterns in "
            printf "GLOBIGNORE, it is removed from the list of "
            printf "matches. \n\n"
            printf "The pattern matching honors the setting of "
            printf "the extglob shell option.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of GLOBIGNORE : $GLOBIGNORE"
            ;;
        50) printf "GROUPS\n\n"
            printf "An array variable containing the list of "
            printf "groups of which the current user is a member. \n\n"
            printf "Assignments to GROUPS have no effect. \n\n"
            printf "If GROUPS is unset, it loses its special "
            printf "properties, even if it is subsequently reset.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of GROUPS : $GROUPS"
            ;;
        51) printf "histchars\n\n"
            printf "Up to three characters which control history "
            printf "expansion, quick substitution, and tokenization. \n\n"
            printf "The first character is the history expansion character, "
            printf "that is, the character which signifies the start of a history "
            printf "expansion, normally ‘!’. \n\n"
            printf "The second character is the character which signifies "
            printf "‘quick substitution’ when seen as the first character "
            printf "on a line, normally ‘^’. \n\n"
            printf "The optional third character is the character which "
            printf "indicates that the remainder of the line is a "
            printf "comment when found as the first character of a word, "
            printf "usually ‘#’. \n\n"
            printf "The history comment character causes history "
            printf "substitution to be skipped for the remaining "
            printf "words on the line. \n\n"
            printf "It does not necessarily cause the shell parser "
            printf "to treat the rest of the line as a comment.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of histchars : $histchars"
            ;;
        52) printf "HISTCMD\n\n"
            printf "The history number, or index in the history list, "
            printf "of the current command. \n\n"
            printf "If HISTCMD is unset, it loses its special properties, "
            printf "even if it is subsequently reset.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of HISTCMD : $HISTCMD"
            ;;
        53) printf "HISTCONTROL\n\n"
            printf "A colon-separated list of values controlling how "
            printf "commands are saved on the history list. \n\n"
            printf "If the list of values includes ‘ignorespace’, "
            printf "lines which begin with a space character are not "
            printf "saved in the history list. \n\n"
            printf "A value of ‘ignoredups’ causes lines which match "
            printf "the previous history entry to not be saved. \n\n"
            printf "A value of ‘ignoreboth’ is shorthand for "
            printf "‘ignorespace’ and ‘ignoredups’. \n\n"
            printf "A value of ‘erasedups’ causes all previous lines "
            printf "matching the current line to be removed from "
            printf "the history list before that line is saved. \n\n"
            printf "Any value not in the above list is ignored. \n\n"
            printf "If HISTCONTROL is unset, or does not include "
            printf "a valid value, all lines read by the shell parser "
            printf "are saved on the history list, subject to the "
            printf "value of HISTIGNORE. \n\n"
            printf "The second and subsequent lines of a multi-line "
            printf "compound command are not tested, and are added "
            printf "to the history regardless of the value of HISTCONTROL.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of HISTCONTROL : $HISTCONTROL"
            ;;
        54) printf "HISTFILE\n\n"
            printf "The name of the file to which the command "
            printf "history is saved. \n\n"
            printf "The default value is ~/.bash_history.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of HISTFILE : $HISTFILE"
            ;;
        55) printf "HISTFILESIZE\n\n"
            printf "The maximum number of lines contained in the "
            printf "history file. \n\n"
            printf "When this variable is assigned a value, "
            printf "the history file is truncated, if necessary, "
            printf "to contain no more than that number of lines "
            printf "by removing the oldest entries. \n\n"
            printf "The history file is also truncated to this "
            printf "size after writing it when a shell exits. \n\n"
            printf "If the value is 0, the history file is "
            printf "truncated to zero size. \n\n"
            printf "Non-numeric values and numeric values less "
            printf "than zero inhibit truncation. \n\n"
            printf "The shell sets the default value to the "
            printf "value of HISTSIZE after reading any startup files.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of HISTFILESIZE : $HISTFILESIZE"
            ;;
        56) printf "HISTIGNORE\n\n"
            printf "A colon-separated list of patterns used to decide "
            printf "which command lines should be saved on the "
            printf "history list. \n\n"
            printf "Each pattern is anchored at the beginning of the "
            printf "line and must match the complete line "
            printf "(no implicit ‘*’ is appended). \n\n"
            printf "Each pattern is tested against the line "
            printf "after the checks specified by HISTCONTROL are "
            printf "applied. \n\n"
            printf "In addition to the normal shell pattern matching "
            printf "characters, ‘&’ matches the previous history line. \n\n"
            printf "‘&’ may be escaped using a backslash.\n\n"
            printf "The backslash is removed before attempting a match. \n\n"
            printf "The second and subsequent lines of a multi-line "
            printf "compound command are not tested, and are added to " 
            printf "the history regardless of the value of HISTIGNORE. \n\n"
            printf "The pattern matching honors the setting of the "
            printf "extglob shell option.\n\n"
            printf "HISTIGNORE subsumes the function of HISTCONTROL. \n\n"
            printf "A pattern of ‘&’ is identical to ignoredups, "
            printf "and a pattern of ‘[ ]*’ is identical to ignorespace. \n\n"
            printf "Combining these two patterns, separating them with a "
            printf "colon, provides the functionality of ignoreboth.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of HISTIGNORE : $HISTIGNORE"
            ;;
        57) printf "HISTSIZE\n\n"
            printf "The maximum number of commands to remember "
            printf "on the history list. \n\n"
            printf "If the value is 0, commands are not saved in " 
            printf "the history list. Numeric values less than zero "
            printf "result in every command being saved on the history "
            printf "list (there is no limit). \n\n"
            printf "The shell sets the default value to 500 after reading "
            printf "any startup files.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of HISTSIZE : $HISTSIZE"
            ;;
        58) printf "HISTTIMEFORMAT\n\n"
            printf "If this variable is set and not null, its value is used " 
            printf "as a format string for strftime to print the time stamp "
            printf "associated with each history entry displayed by the " 
            printf "history builtin. \n\n"
            printf "If this variable is set, time stamps are written to the "
            printf "history file so they may be preserved across shell "
            printf "sessions. \n\n"
            printf "This uses the history comment character to distinguish "
            printf "timestamps from other history lines.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of HISTTIMEFORMAT : $HISTTIMEFORMAT"
            ;;
        59) printf "HOSTFILE\n\n"
            printf "Contains the name of a file in the same format as "
            printf "/etc/hosts that should be read when the shell needs "
            printf "to complete a hostname.\n\n"
            printf "The list of possible hostname completions may be "
            printf "changed while the shell is running.\n\n"
            printf "The next time hostname completion is attempted after "
            printf "the value is changed, Bash adds the contents of the "
            printf "new file to the existing list. \n\n"
            printf "If HOSTFILE is set, but has no value, or does not "
            printf "name a readable file, Bash attempts to read /etc/hosts "
            printf "to obtain the list of possible hostname completions. \n\n"
            printf "When HOSTFILE is unset, the hostname list is cleared.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of HOSTFILE : $HOSTFILE"
            ;;
        60) printf "HOSTNAME\n\n"
            printf "The name of the current host.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of HOSTNAME : $HOSTNAME"
            ;;
        61) printf "HOSTTYPE\n\n"
            printf "A string describing the machine Bash is running on.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of HOSTTYPE : $HOSTTYPE"
            ;;
        62) printf "IGNOREEOF\n\n"
            printf "Controls the action of the shell on receipt of an EOF "
            printf "character as the sole input. \n\n"
            printf "If set, the value denotes the number of consecutive EOF "
            printf "characters that can be read as the first character on an "
            printf "input line before the shell will exit. \n\n"
            printf "If the variable exists but does not have a "
            printf "numeric value, or has no value, then the default "
            printf "is 10. \n\n"
            printf "If the variable does not exist, then EOF "
            printf "signifies the end of input to the shell. \n\n"
            printf "This is only in effect for interactive shells.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of IGNOREEOF : $IGNOREEOF"
            ;;
        63) printf "INPUTRC\n\n"
            printf "The name of the Readline initialization file, "
            printf "overriding the default of ~/.inputrc.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of INPUTRC : $INPUTRC"
            ;;
        64) printf "INSIDE_EMACS\n\n"
            printf "If Bash finds this variable in the environment when "
            printf "the shell starts, it assumes that the shell is running "
            printf "in an Emacs shell buffer and may disable line editing "
            printf "depending on the value of TERM.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of INSIDE_EMACS : $INSIDE_EMACS"
            ;;
        65) printf "LANG\n\n"
            printf "Used to determine the locale category for any category "
            printf "not specifically selected with a variable starting with LC_.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of LANG : $LANG"
            ;;
        66) printf "LC_ALL\n\n"
            printf "This variable overrides the value of LANG and any other LC_ "
            printf "variable specifying a locale category.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of LC_ALL : $LC_ALL"
            ;;
        67) printf "LC_COLLATE\n\n"
            printf "This variable determines the collation order used when "
            printf "sorting the results of filename expansion, and "
            printf "determines the behavior of range expressions, "
            printf "equivalence classes, and collating sequences within "
            printf "filename expansion and pattern matching.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of LC_COLLATE : $LC_COLLATE"
            ;;
        68) printf "LC_CTYPE\n\n"
            printf "This variable determines the interpretation of "
            printf "characters and the behavior of character classes "
            printf "within filename expansion and pattern matching.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of LC_CTYPE : $LC_CTYPE"
            ;;
        69) printf "LC_MESSAGES\n\n"
            printf "This variable determines the locale used to "
            printf "translate double-quoted strings preceded by a "
            printf "‘$’.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of LC_MESSAGES : $LC_MESSAGES"
            ;;
        70) printf "LC_NUMERIC\n\n"
            printf "This variable determines the locale category "
            printf "used for number formatting.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of LC_NUMERIC : $LC_NUMERIC"
            ;;
        71) printf "LC_TIME\n\n"
            printf "This variable determines the locale category "
            printf "used for data and time formatting.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of LC_TIME : $LC_TIME"
            ;;
        72) printf "LINENO\n\n"
            printf "The line number in the script or shell "
            printf "function currently executing.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of LINENO : $LINENO"
            ;;
        73) printf "LINES\n\n"
            printf "Used by the select command to determine "
            printf "the column length for printing selection "
            printf "lists. \n\n"
            printf "Automatically set if the checkwinsize option "
            printf "is enabled (see The Shopt Builtin), "
            printf "or in an interactive shell upon receipt of "
            printf "a SIGWINCH.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of LINES : $LINES"
            ;;
        74) printf "MACHTYPE\n\n"
            printf "A string that fully describes the system type "
            printf "on which Bash is executing, in the standard "
            printf "GNU cpu-company-system format.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of MACHTYPE : $MACHTYPE"
            ;;
        75) printf "MAILCHECK\n\n"
            printf "How often (in seconds) that the shell should "
            printf "check for mail in the files specified in the "
            printf "MAILPATH or MAIL variables. \n\n"
            printf "The default is 60 seconds. \n\n"
            printf "When it is time to check for mail, "
            printf "the shell does so before displaying "
            printf "the primary prompt. \n\n"
            printf "If this variable is unset, or set "
            printf "to a value that is not a number greater "
            printf "than or equal to zero, the shell "
            printf "disables mail checking.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of MAILCHECK : $MAILCHECK"
            ;;
        76) printf "MAPFILE\n\n"
            printf "An array variable created to hold the text "
            printf "read by the mapfile builtin when no variable "
            printf "name is supplied.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of MAPFILE : $MAPFILE"
            ;;
        77) printf "OLDPWD\n\n"
            printf "The previous working directory as set by the cd "
            printf "builtin.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of OLDPWD : $OLDPWD"
            ;;
        78) printf "OPTERR\n\n"
            printf "If set to the value 1, Bash displays error "
            printf "messages generated by the getopts builtin command.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of OPTERR : $OPTERR"
            ;;
        79) printf "OSTYPE\n\n"
            printf "A string describing the operating system "
            printf "Bash is running on.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of OSTYPE : $OSTYPE"
            ;;
        80) printf "PIPESTATUS\n\n"
            printf "An array variable (see Arrays) containing a "
            printf "list of exit status values from the processes "
            printf "in the most-recently-executed foreground pipeline "
            printf "(which may contain only a single command).\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of PIPESTATUS : $PIPESTATUS"
            ;;
        81) printf "POSIXLY_CORRECT\n\n"
            printf "If this variable is in the environment when Bash "
            printf "starts, the shell enters POSIX mode before reading " 
            printf "the startup files, as if the --posix invocation "
            printf "option had been supplied. \n\n"
            printf "If it is set while the shell is running, "
            printf "Bash enables POSIX mode, as if the command :\n\n"
            printf "\n set -o posix \n\n"
            printf "had been executed. \n\n"
            printf "When the shell enters POSIX mode, it "
            printf "sets this variable if it was not already set.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of POSIXLY_CORRECT : $POSIXLY_CORRECT"
            ;;
        82) printf "PPID\n\n"
            printf "The process ID of the shell’s parent "
            printf "process. \n\n"
            printf "This variable is readonly.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of PPID : $PPID"
            ;;
        83) printf "PROMPT_COMMAND\n\n"
            printf "If set, the value is interpreted as a "
            printf "command to execute before the printing "
            printf "of each primary prompt ($ PS1).\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of PROMPT_COMMAND : $PROMPT_COMMAND"
            ;;
        84) printf "PROMPT_DIRTRIM\n\n"
            printf "If set to a number greater than zero, "
            printf "the value is used as the number of trailing "
            printf "directory components to retain when expanding " 
            printf "the \ w and \ W prompt string escapes. \n\n"
            printf "Characters removed are replaced with an ellipsis.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of PROMPT_DIRTRIM : $PROMPT_DIRTRIM"
            ;;
        85) printf "PS0\n\n"
            printf "The value of this parameter is expanded like PS1 and "
            printf "displayed by interactive shells after reading a "
            printf "command and before the command is executed.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of PS0 : $PS0"
            ;;
        86) printf "PS3\n\n"
            printf "The value of this variable is used as the prompt for the "
            printf "select command. \n\n"            
            printf "If this variable is not set, the select command "
            printf "prompts with ‘#? ’\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of PS3 : $PS3"
            ;;
        87) printf "PS4\n\n"
            printf "The value of this parameter is expanded like PS1 and the "
            printf "expanded value is the prompt printed before the command "
            printf "line is echoed when the -x option is set. \n\n"
            printf "The first character of the expanded value is replicated "
            printf "multiple times, as necessary, to indicate multiple levels " 
            printf "of indirection. \n\n"
            printf "The default is ‘+ ’.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of PS4 : $PS4"
            ;;
        88) printf "PWD\n\n"
            printf "The current working directory as set by the cd builtin.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of PWD : $PWD"
            ;;
        89) printf "RANDOM\n\n"
            printf "Each time this parameter is referenced, a random integer "
            printf "between 0 and 32767 is generated. \n\n"
            printf "Assigning a value to this variable seeds the random number "
            printf "generator.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of RANDOM : $RANDOM"
            ;;
        90) printf "READLINE_LINE\n\n"
            printf "The contents of the Readline line buffer, "
            printf "for use with ‘bind -x’.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of READLINE_LINE : $READLINE_LINE"
            ;;
        91) printf "READLINE_POINT\n\n"
            printf "The position of the insertion point in the "
            printf "Readline line buffer, for use with ‘bind -x’.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of READLINE_POINT : $READLINE_POINT"
            ;;
        92) printf "REPLY\n\n"
            printf "The default variable for the read builtin.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of REPLY : $REPLY"
            ;;
        93) printf "SECONDS\n\n"
            printf "This variable expands to the number of seconds since "
            printf "the shell was started. \n\n"
            printf "Assignment to this variable resets the count to the "
            printf "value assigned, and the expanded value becomes the "
            printf "value assigned plus the number of seconds since "
            printf "the assignment.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of SECONDS : $SECONDS"
            ;;
        94) printf "SHELL\n\n"
            printf "The full pathname to the shell is kept in this "
            printf "environment variable. \n\n"
            printf "If it is not set when the shell starts, Bash "
            printf "assigns to it the full pathname of the current " 
            printf "user’s login shell. \n\n"
            printf "\n\n\n\n"
            printf "Current State Value of SHELL : $SHELL"
            ;;
        95) printf "SHELLOPTS\n\n"
            printf "A colon-separated list of enabled shell options. \n\n"
            printf "Each word in the list is a valid argument for "
            printf "the - o option to the set builtin command. \n\n"            
            printf "The options appearing in SHELLOPTS are those reported "
            printf "as ‘on’ by ‘set -o’. \n\n"            
            printf "If this variable is in the environment when Bash "
            printf "starts up, each shell option in the list will "
            printf "be enabled before reading any startup files. \n\n"
            printf "This variable is readonly.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of SHELLOPTS : $SHELLOPTS"
            ;;
        96) printf "SHLVL\n\n"
            printf "Incremented by one each time a new instance of Bash "
            printf "is started. \n\n"
            printf "This is intended to be a count of how deeply your "
            printf "Bash shells are nested.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of SHLVL : $SHLVL"
            ;;
        97) printf "TIMEFORMAT\n\n"
            printf "The value of this parameter is used as a format "
            printf "string specifying how the timing information for "
            printf "pipelines prefixed with the time reserved word "
            printf "should be displayed. \n\n"
            printf "The ‘%’ character introduces an escape sequence "
            printf "that is expanded to a time value or other "
            printf "information. \n\n"
            printf "The escape sequences and their meanings "
            printf "are as follows;the braces denote optional portions.\n\n"
            printf "If the value is null, no timing information "
            printf "is displayed. \n\n"
            printf "A trailing newline is added when the format "
            printf "string is displayed.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of TIMEFORMAT : $TIMEFORMAT"
            ;;
        98) printf "TMOUT\n\n"
            printf "If set to a value greater than zero, "
            printf "TMOUT is treated as the default timeout "
            printf "for the read builtin (see Bash Builtins). \n\n"
            printf "The select command (see Conditional Constructs) "
            printf "terminates if input does not arrive after TMOUT  "
            printf "seconds when input is coming from a terminal.\n\n"
            printf "In an interactive shell, the value is interpreted "
            printf "as the number of seconds to wait for a line " 
            printf "of input after issuing the primary prompt. \n\n"
            printf "Bash terminates after waiting for that number " 
            printf "of seconds if a complete line of input does "
            printf "not arrive.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of TMOUT : $TMOUT"
            ;;
        99) printf "TMPDIR\n\n"
            printf "If set, Bash uses its value as the name of a "
            printf "directory in which Bash creates temporary "
            printf "files for the shell’s use.\n\n"
            printf "\n\n\n\n"
            printf "Current State Value of TMPDIR : $TMPDIR"
            ;;
        100) printf "UID\n\n"
             printf "The numeric real user id of the current user. \n\n"
             printf "This variable is readonly.\n\n"
             printf "\n\n\n\n"
             printf "Current State Value of UID : $UID"
             ;;
    esac
    EXIT    
}

function INVALID_INPUT_MSG() {
    printf "Invalid Input \nPress any key to Retry...."
    read RETRY_KEY
}

function shell_variables_incorrect_option() {
    INVALID_INPUT_MSG
    welcome_function
    shell_variables
}

function Bourne_Shell_Variables_incorrect_option() {
    INVALID_INPUT_MSG
    Bourne_Shell_Variables
}

function BASH_Variables_incorrect_option() {
    INVALID_INPUT_MSG
    BASH_Variables
}

function EXIT() {
    printf "\n\n\nPress any key to Exit...."
    read EXIT_KEY
    clear
}

welcome_function
shell_variables